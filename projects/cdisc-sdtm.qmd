---
title: "Study Data Tabulation Model (SDTM)-Demographics (DM)"
description: "From metadata-driven empty shells to mapped DM and SUPPDM — clean, reproducible, and CDISC-ready"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    number-sections: false
categories: [CDISC, SAS, SDTM, MACRO]
permalink: /projects/cdisc-sdtm.html
---

> Source code & metadata: [see GitHub repo (02_SDTM).](https://github.com/Ousmanerabi/clinical-trials-programming-portfolio/tree/main/02_SDTM)\
> Environment: SAS OnDemand 9.4.

## Overview

-   **Goal:** Build SDTM **DM** (Demographics) + **SUPPDM** from raw/source data using a **metadata-driven** approach (empty shells → mapping → derivations → sort/export).
-   **Why:** Ensure CDISC consistency (identifiers, timing in ISO 8601, roles/keys) and reproducibility in SAS OnDemand.
-   **Outputs:** `TARGET.DM` (1 record per subject) and `TARGET.SUPPDM` (non-standard qualifiers).

::: callout-note
**Context**\
- Tools: *SAS OnDemand* (9.4), macros from my study notes.\
- Source folders (OnDemand):\
- `SOURCE` → raw tables (e.g., `DEMOGRAPHIC`, `DOSING`)\
- `LIB` → formats (user-defined formats)\
- `TARGET` → SDTM outputs (`DM.sas7bdat`, `SUPPDM.sas7bdat`)\
- Metadata: `/home/.../SDTM_METADATA1.csv` (variable list and attributes).
:::

------------------------------------------------------------------------

## Inputs

-   **Metadata CSV:** `SDTM_METADATA1.csv` (variables, roles, lengths, types, sort keys).
-   **Source data:**
    -   `SOURCE.DEMOGRAPHIC` (1 ligne/sujet, ex. `subject`, `dob`, `gender`, `trt`, `uniqueid`)\
    -   `SOURCE.DOSING` (ex. `subject`, `startdt`, `enddt`)
-   **Formats (libref `LIB`):** `sex_demographic_gender.`, `race_demographic_race.`, `armcd_demographic_trt.`, `$arm_demographic_trt.`\
-   **Environment:** SAS OnDemand 9.4; librefs `SOURCE`, `LIB`, `TARGET`.

<details>

<summary><strong>SAS — Library setup</strong></summary>

``` sas
/* Common paths & librefs */ 

%include "/home/u64197545/CDISC/appendix/common.sas"; 

/* expects: 

 libname source "/home/u64197545/CDISC/data";

 libname lib  "/home/u64197545/CDISC/formats"; 

libname target  "/home/u64197545/CDISC/sdtm"; 

*/
```

</details>

## 1) Create EMPTY DM from Metadata

We first create an **empty shell** (`EMPTY_DM`) using the CSV metadata so that attributes (type/length/label/order) are correct and we can **append real data into it**.

<details><summary><strong>SAS — Build EMPTY_DM</strong></summary>

```         
*---------------------------------------------------------------*;
* make_empty_dataset.sas creates a zero record dataset based on a 
* dataset metadata spreadsheet.  The dataset created is called
* EMPTY_** where "**" is the name of the dataset.  This macro also
* creates a global macro variable called **KEEPSTRING that holds 
* the dataset variables desired and listed in the order they  
* should appear.  [The variable order is dictated by VARNUM in the 
* metadata spreadsheet.]
*
* MACRO PARAMETERS:
* metadatafile = the CSV file containing the dataset metadata
* dataset = the dataset or domain name you want to extract

	*---------------------------------------------------------------*;


/* Create empty based on metadata CSV */
%macro make_empty_dataset(metadatafile=, dataset=);

/* Import csv file and rename it _temp */
	proc import datafile="&metadatafile" out=_temp dbms=csv replace;
		guessingrows=max;
		delimiter=";";
		encoding='utf-8';
	run;



	** sort the dataset by expected specified variable order (varnum);

	proc sort data=_temp;
		where domain="&dataset";
		by varnum;
	run;



	** create keepstring macro variable and load metadata 
    ** information into macro variables;
	
	
	
	%global &dataset.KEEPSTRING;


	data _null_;
		set _temp nobs=nobs end=eof;

		if _n_=1 then
			call symput("vars", compress(put(nobs, 3.)));
		call symputx('var'    || compress(put(_n_, 3.)), variable);
		call symputx('label'  || compress(put(_n_, 3.)), label);
		call symputx('length' || compress(put(_n_, 3.)), put(length, 3.));
		** valid ODM types include TEXT, INTEGER, FLOAT, DATETIME, 

			        ** DATE, TIME and map to SAS numeric or character;

		if upcase(type) in ("INTEGER", "FLOAT") then
			call symputx('type' || compress(put(_n_, 3.)), "");
		else if upcase(type) in ("TEXT", "DATE", "DATETIME", "TIME") then
			call symputx('type' || compress(put(_n_, 3.)), "$");
		else
			put "ERR" "OR: not using a valid ODM type.  " type=;
		** create **KEEPSTRING macro variable;
		length keepstring $ 32767;
		retain keepstring;
		keepstring=compress(keepstring) || "|" || left(variable);

		if eof then
			call symputx(upcase(compress("&dataset" || 'KEEPSTRING')), 
				left(trim(translate(keepstring, " ", "|"))));
	run;



	** create a 0-observation template data set used for assigning 

		    ** variable attributes to the actual data sets;

	data EMPTY_&dataset;
		%do i=1 %to &vars;
			attrib &&var&i label="&&label&i" 
			%if "&&length&i" ne "" %then
				length=&&type&i.&&length&i...;
			;

			%if &&type&i=$ %then
				retain &&var&i '';
			%else
				retain &&var&i .;
			;
		%end;

		if 0;
	run;

%mend make_empty_dataset;

/* Result: WORK.EMPTY_DM with 0 obs, all expected variables/attributes */
```

</details>

:::{.callout-tip}

If you don’t use a macro, you can `PROC IMPORT` the metadata and create the shell with `DATA _NULL_` + `CALL EXECUTE`, or keep a hand-crafted `length/label/format` block.

:::

## 2) Mapping (Raw data to SDTM DM using SDTMIG v3.4)

Key SDTM variables for DM (subset):

| Class | Variables (examples) | Notes |
|----|----|----|
| Identifier | `STUDYID`, `DOMAIN`, `USUBJID`, `SUBJID` | 1 record per subject |
| Timing | `RFSTDTC`, `RFENDTC`, `RFXSTDTC`, `RFXENDTC`, `BRTHDTC` | ISO 8601 dates |
| Qualifier | `SITEID`, `SEX`, `RACE`, `COUNTRY`, `AGE`, `AGEU` | Coded via formats where applicable |
| Arm | `ARMCD`, `ARM`, `ACTARMCD`, `ACTARM` | From treatment assignments |

## 3) Create formats

<details><summary><strong>SAS — Creating custom format </strong></summary>

``` sas
/* Creating custom format for the variables sex, race, arm, and armcd.*/

proc format;
	value sex 1='M' 2='F' .='U';
	value race 1='White' 2='Black or African American' 3='Asian';
	value armcd 0='PLACEBO' 1='ALG123';
	value arm 0='Placebo' 1='Analgezia HCL 30mg';
run;
```

<details>

## 4) Derive the logic variables that need calculating (Dosing for example)

<details><summary><strong>SAS — Prepare dosing </strong></summary>

```         
/* First/last dose (for RFSTDTC/RFENDTC) */

**** GET FIRST AND LAST DOSE DATE FOR RFSTDTC AND RFENDTC;
proc sort 
  data=source.dosing(keep=subject startdt enddt) 
  out=dosing;
   by subject startdt;
run;

**** FIRSTDOSE=FIRST DOSING AND LASTDOSE=LAST DOSING;

data dosing;
  set dosing; 
    by subject;
    
    retain firstdose lastdose;
    
  if first.subject then 
    do; 
       firstdose=.; 
       lastdose=.; 
    end;
    
  firstdose = min(firstdose, startdt, enddt);
  lastdose  = max(lastdose , startdt, enddt);
  
  if last.subject;
run;
```

## 5) Combine all the data

<details><summary><strong>SAS — Map to DM variables</strong></summary>

```         
**** GET DEMOGRAPHICS DATA;
proc sort
  data=source.demographic
  out=demographic;
    by subject;
run;

**** MERGE DEMOGRAPHICS AND FIRST DOSE DATE;
data demog_dose;
  merge demographic
        dosing;
    by subject;
run;


**** DERIVE THE MAJORITY OF SDTM DM VARIABLES;
options missing = ' ';
data dm;
  set EMPTY_DM
    demog_dose(rename=(race=_race));

    studyid = 'XYZ123';
    domain = 'DM';
    usubjid = left(uniqueid);
    subjid = put(subject,3.); 
    rfstdtc = put(firstdose,yymmdd10.);  
    rfendtc = put(lastdose,yymmdd10.); 
    rfxstdtc = put(firstdose,yymmdd10.);  
    rfxendtc = put(lastdose,yymmdd10.);
    rficdtc = put(icdate,yymmdd10.);
    rfpendtc = put(lastdoc,yymmdd10.);
    dthfl = 'N';
    siteid = substr(subjid,1,1) || "00";
    brthdtc = put(dob,yymmdd10.);
    age = floor ((intck('month',dob,firstdose) - 
          (day(firstdose) < day(dob))) / 12);
    if age ne . then
      ageu = 'YEARS';
    sex = put(gender,sex.);
    race = put(_race,race.);
    armcd = put(trt,armcd.);
    arm = put(trt,arm.);
    actarmcd = put(trt,armcd.);
    actarm = put(trt,arm.);
    country = "USA"; 
run; 
```

</details>

## 6) Order, Keys & Export

Sort by **metadata-defined** keys and save to `TARGET`.

<details><summary><strong>SAS — Sort</strong></summary>

``` sas
*----------------------------------------------------------------*;
* make_sort_order.sas creates a global macro variable called  
* **SORTSTRING where ** is the name of the dataset that contains  
* the KEYSEQUENCE metadata specified sort order for a given dataset.
*
* MACRO PARAMETERS:
* metadatafile = the file containing the dataset metadata
* dataset = the dataset or domain name

	*----------------------------------------------------------------*;

%macro make_sort_order(metadatafile=, dataset=);


	proc import datafile="&metadatafile" out=_temp dbms=csv replace;
		guessingrows=max;
		delimiter=";";
		encoding='utf-8';
	run;


	proc sort data=_temp;
		where keysequence ne . and domain="&dataset";
		by keysequence;
	run;

	** create **SORTSTRING macro variable;
	%global &dataset.SORTSTRING;

	data _null_;
		set _temp end=eof;
		length domainkeys $ 200;
		retain domainkeys '';
		domainkeys=trim(domainkeys) || ' ' || trim(put(variable, 8.));

		if eof then
			call symputx(compress("&dataset" || "SORTSTRING"), domainkeys);
	run;

%mend make_sort_order;
```

<details><summary><strong>SAS — Save</strong></summary>

```         

**** SORT DM ACCORDING TO METADATA AND SAVE PERMANENT DATASET;
%make_sort_order(metadatafile=/home/u64197545/CDISC/Chap2/SDTM_METADATA1.csv,dataset=DM);

proc sort
  data=dm(keep = &DMKEEPSTRING)
  out=target.dm;
    by &DMSORTSTRING;
run;

```

</details>

------------------------------------------------------------------------

## 7) QC & Validation

-   **Structural checks**: variable names, type, length, labels match metadata

-   **Controlled terminology**: values mapped via formats/codelists

-   **Timing**: ISO 8601, completeness of `RFSTDTC`/`RFXSTDTC` etc.

-   **Keys**: 1 record per subject; `USUBJID` uniqueness

-   **Cross-domain**: consistency with EX/AE/VS if applicable

<details><summary><strong>SAS — Quick sanity checks</strong></summary>

```         
/* 1 record per USUBJID? */
proc sql;
  select usubjid, count(*) as n
  from target.dm
  group by usubjid
  having calculated n > 1;
quit;

/* Required fields not missing? (example) */
proc freq data=target.dm;
  tables studyid*usubjid*domain / missing list;
run;
```

</details>

## 8) Outputs

![SDTM-DM](images/SDTM_DM_Table.png){fig-align="center" width="80%"}

![Proc content](images/SDTM-Contents1.png){fig-align="center" width="80%"}

![PROC contents](images/SDTM-Contents2.png){fig-align="center" width="80%"}

## 
